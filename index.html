<!doctype html>
<html lang="el">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Strike!!! — Legendary Edition (VIP + Ranks)</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
<style>
:root{
  --bg1:#2b0652; --bg2:#6b2a83; --bg3:#e98cd9;
  --panel: rgba(0,0,0,0.36);
  --glass: rgba(255,255,255,0.04);
  --accent-grad: linear-gradient(90deg,#ffd54a,#ff6b6b,#9b59b6);
  --vip-glow: 0 18px 60px rgba(255,215,75,0.14);
  --ui-font-size: 16px;
}
*{box-sizing:border-box;font-family:Montserrat,system-ui,Arial}
html,body{height:100%;margin:0;background:radial-gradient(circle at 10% 10%, var(--bg1) 0%, var(--bg2) 40%, var(--bg3) 100%);color:#fff;overflow:hidden}
#gameWrap{position:relative;width:100vw;height:100vh}
canvas{display:block;background:transparent}

/* HUD */
.hud{position:absolute;z-index:40;left:18px;top:18px;display:flex;gap:12px;align-items:center;font-size:var(--ui-font-size)}
.panel{background:var(--panel);backdrop-filter:blur(6px);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 28px rgba(0,0,0,0.35)}
.title{position:absolute;left:50%;transform:translateX(-50%);top:16px;font-weight:900;letter-spacing:2px;font-size:22px;text-transform:uppercase}

.hud-right{position:absolute;right:18px;top:18px;z-index:40;display:flex;flex-direction:column;gap:10px;transition:opacity .25s,transform .2s}
.hud-right.hidden{opacity:0;transform:translateX(12px);pointer-events:none}

/* small toggle button placed inside hud-right header */
.statsToggleBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:10px;cursor:pointer;font-size:13px}

/* Controls (bottom) */
.controls{position:absolute;left:50%;transform:translateX(-50%);bottom:28px;z-index:40;display:flex;gap:10px}
.btn{background:var(--glass);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;min-width:84px;text-align:center;font-size:14px}
.btn.primary{background:var(--accent-grad);color:#111;border:none;box-shadow:0 8px 28px rgba(0,0,0,0.35)}
.btn.ghost{background:transparent;border:1px dashed rgba(255,255,255,0.06)}

/* overlay + menus */
.overlay{position:fixed;inset:0;background:linear-gradient(180deg,rgba(0,0,0,0.5),rgba(0,0,0,0.65));backdrop-filter:blur(6px);z-index:90;display:none;align-items:center;justify-content:center}
.menu{position:relative;z-index:100;min-width:360px;background:linear-gradient(180deg,rgba(8,6,14,0.68),rgba(8,6,14,0.55));padding:22px;border-radius:16px;border:1px solid rgba(255,255,255,0.06);display:none;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
.menu h2{margin:0 0 8px 0}
.row{display:flex;gap:10px;flex-wrap:wrap}
.skinCard{padding:12px;border-radius:12px;min-width:120px;text-align:center;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
.skinPreview{width:56px;height:56px;border-radius:50%;margin-bottom:6px;border:2px solid rgba(255,255,255,0.05);display:inline-block}

.dif{display:flex;gap:10px;margin-top:10px}
.badge{padding:8px 12px;border-radius:999px;cursor:pointer;background:rgba(255,255,255,0.03);backdrop-filter:blur(4px)}
.badge.active{box-shadow:0 6px 22px rgba(0,0,0,0.45);background:var(--accent-grad);color:#111}
.badge.locked{opacity:0.35;cursor:not-allowed}
.small{font-size:13px;opacity:0.88}
.legend{position:absolute;left:18px;bottom:18px;z-index:40;padding:8px 12px;border-radius:12px;background:linear-gradient(90deg,#ffb347,#ffcc33);color:#111;font-weight:800;box-shadow:var(--vip-glow)}
.vipBadge{background:linear-gradient(90deg,#ffd54a,#ffb347);color:#111;padding:8px 12px;border-radius:999px;font-weight:800;box-shadow:var(--vip-glow)}
.achList{max-height:320px;overflow:auto;margin-top:8px}
.achItem{padding:10px;border-radius:10px;margin-bottom:8px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
.achUnlocked{background:linear-gradient(90deg,#7afcff,#8d7aff);color:#111}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:100px;background:rgba(0,0,0,0.7);padding:12px 16px;border-radius:12px;z-index:120;color:#fff}

.cardModal{min-width:360px}
.field{margin-bottom:10px}
input,select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#fff}

@media (max-width:520px){.menu{min-width:92vw}.hud{flex-direction:column;left:12px;top:12px}.controls{flex-wrap:wrap;gap:8px}}

/* pulse etc */
.pulse{animation:pulse 1.6s infinite}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)}}
.modal-open canvas, .modal-open .hud, .modal-open .controls, .modal-open .legend { filter: blur(6px) brightness(0.6); pointer-events: none; }
.modal-open .hud-right { filter: blur(6px) brightness(0.6); pointer-events: none}

/* RANK BADGE */
.rankBadge{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,#7c4dff,#ff6b6b);color:#111;font-weight:700}

/* small sparkles */
.sparkle{position:absolute;width:6px;height:6px;border-radius:50%;background:rgba(255,255,255,0.85);filter:blur(0.6px);opacity:0.9}

/* Intro */
#intro{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:200;background:linear-gradient(180deg,rgba(0,0,0,0.5),rgba(0,0,0,0.7));backdrop-filter:blur(4px);}
.introCard{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));padding:28px;border-radius:16px;border:1px solid rgba(255,255,255,0.06);text-align:center;max-width:540px}
.logo{font-size:36px;font-weight:900;letter-spacing:4px;margin-bottom:8px}
.introSub{font-size:14px;opacity:0.9;margin-bottom:14px}

/* SKINS HORIZONTAL SCROLLER: container + slider */
#skinsScrollWrap{display:flex;flex-direction:column;gap:8px}
#skinsList{display:flex;gap:12px;overflow:hidden;padding-bottom:6px;scroll-behavior:smooth;height:140px;align-items:center}
.skinCard{min-width:120px;flex:0 0 auto}
.shopControls{display:flex;align-items:center;gap:8px;justify-content:space-between;margin-top:6px}
.slideRange{width:100%;-webkit-appearance:none;height:6px;border-radius:6px;background:rgba(255,255,255,0.06);outline:none}

/* play mode adjustments */
body.playing .title{font-size:16px; top:10px}
body.playing .hud{font-size:13px}
body.playing .panel{padding:6px 10px}
body.playing .controls{display:none} /* hide bottom buttons when playing */
body.playing .btn{min-width:72px;padding:8px 10px;font-size:13px}
body.playing .legend{font-size:12px;bottom:14px;left:14px;padding:6px 10px}
body.playing .skinPreview{width:44px;height:44px}
body.playing .achItem{padding:8px}
body.playing .rankBadge{padding:6px 10px;font-size:13px}

/* small arrow buttons for shop */
.shopArrow{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:10px;cursor:pointer;min-width:36px;text-align:center}
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="gameCanvas"></canvas>

  <div class="hud">
    <div class="panel"><div id="lives">❤ x1</div></div>
    <div class="panel"><div id="levelDisplay">Level: 1</div></div>
    <div class="panel"><div id="scoreDisplay">Score: 0</div></div>
  </div>

  <div class="hud-right" id="hudRight">
    <div style="display:flex;gap:8px;align-items:center">
      <div class="panel"><div id="coinsDisplay">Coins: 0</div></div>
      <button id="toggleStatsView" class="statsToggleBtn small">Hide Stats</button>
    </div>
    <div class="panel"><div id="highDisplay">Highest: 0</div></div>
    <div class="panel"><div id="rankPanel">Rank: —</div></div>
    <div class="panel"><div id="vipPanel">VIP: —</div></div>
    <div class="panel"><div id="totalScoreDisplay">Total: 0</div></div>
  </div>

  <div class="title">STRIKE!!! <span class="small">— Version 1.0</span></div>

  <div class="controls" id="mainControls">
    <button id="playBtn" class="btn primary">Play</button>
    <button id="shopBtn" class="btn">Shop</button>
    <button id="achBtn" class="btn">Achievements</button>
    <button id="statsBtn" class="btn">Stats</button>
    <button id="dailyBtn" class="btn">Daily</button>
    <button id="settingsBtn" class="btn">Settings</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>

  <div class="legend">VIP for 1 month — 3000 coins ✨</div>

  <!-- Intro: now contains extra buttons so controls are accessible here too -->
  <div id="intro">
    <div class="introCard">
      <div class="logo">STRIKE!!!</div>
      <div class="introSub">Legendary Edition — VIP gives revive, daily coins, exclusive skins, bonus runs & more.</div>
      <div style="height:12px"></div>
      <div class="row" style="justify-content:center;margin-bottom:8px">
        <button id="introStart" class="btn primary">Start</button>
        <button id="introPlay" class="btn">Play (quick)</button>
        <button id="introShop" class="btn">Shop</button>
        <button id="introAch" class="btn">Achievements</button>
      </div>
      <div style="height:6px"></div>
      <div class="row" style="justify-content:center">
        <button id="introSettings" class="btn">Settings</button>
        <button id="introReset" class="btn ghost">Reset</button>
        <button id="introSkip" class="btn ghost">Skip</button>
      </div>
    </div>
  </div>

  <div id="overlay" class="overlay">
    <div id="menuMain" class="menu" style="display:none;">
      <h2>Welcome, Champion</h2>
      <p class="small">Use ↑/↓ or touch to move. Collect coins, avoid traps. VIP gives 2× coins, revive once/run, daily 75 coins, exclusive skins & more.</p>
      <div style="height:8px"></div>
      <div class="dif">
        <div id="difEasy" class="badge">Easy</div>
        <div id="difMed" class="badge active">Medium</div>
        <div id="difHard" class="badge">Hard</div>
      </div>
      <div style="height:12px"></div>
      <div class="row"><button id="startFromMenu" class="btn primary">Start Game</button><button id="openShopFromMenu" class="btn">Open Shop</button></div>
    </div>

    <div id="menuShop" class="menu">
      <h2>Shop</h2>
      <div id="skinsScrollWrap">
        <div id="skinsList" aria-label="skins list"></div>
        <div class="shopControls">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="shopLeft" class="shopArrow">◀</button>
            <button id="shopRight" class="shopArrow">▶</button>
          </div>
          <input id="shopRange" type="range" class="slideRange" min="0" max="100" value="0" />
          <div style="min-width:80px;text-align:right">
            <button id="backFromShop" class="btn">Back</button>
          </div>
        </div>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="buyLife" class="btn">Buy Life</button>
        <button id="buyVipCoins" class="btn primary">Get VIP (2000 coins)</button>
        <button id="openBuyMenu" class="btn">Buy Coins (Card)</button>
      </div>
    </div>

    <div id="menuBuy" class="menu">
      <h2>Buy Coins</h2>
      <div class="field"><label class="small">Cardholder name</label><input id="cardName" placeholder="Name on card" /></div>
      <div class="field"><label class="small">Card number</label><input id="cardNumber" placeholder="1234 5678 9012 3456" /></div>
      <div class="row">
        <div style="flex:1" class="field"><label class="small">Expiry (MM/YY)</label><input id="cardExpiry" placeholder="08/26" /></div>
        <div style="width:120px" class="field"><label class="small">CVC</label><input id="cardCVC" placeholder="123" /></div>
      </div>
      <div class="field"><label class="small">Amount</label>
        <select id="cardAmount">
          <option value="1">1 USD → 100 coins</option>
          <option value="5">5 USD → 600 coins</option>
          <option value="10">10 USD → 1300 coins</option>
          <option value="20">20 USD → 3000 coins</option>
        
        </select>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="submitPayment" class="btn primary">Pay</button>
        <button id="backFromBuy" class="btn">Back</button>
      </div>
    </div>

    <div id="menuAch" class="menu">
      <h2>Achievements</h2>
      <div class="achList" id="achList"></div>
      <div style="height:8px"></div>
      <div class="row"><button id="claimAll" class="btn">Claim All</button><button id="backFromAch" class="btn primary">Back</button></div>
    </div>

    <div id="menuStats" class="menu">
      <h2>Stats</h2>
      <div id="statsContent" class="small"></div>
      <div style="height:8px"></div>
      <div class="row"><button id="backFromStats" class="btn primary">Back</button></div>
    </div>

    <div id="menuDaily" class="menu">
      <h2>Daily Challenge</h2>
      <div id="dailyContent" class="small"></div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="claimDaily" class="btn primary">Claim Reward</button>
        <button id="backFromDaily" class="btn">Back</button>
      </div>
    </div>

    <div id="menuSettings" class="menu">
      <h2>Settings</h2>
      <div class="row"><button id="toggleSound" class="btn">Toggle Sound</button><button id="clearSaves" class="btn">Clear Saves</button></div>
      <div style="height:10px"></div>
      <button id="backFromSettings" class="btn primary">Back</button>
    </div>
  </div>

  <audio id="bgMusic" loop src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_6efb0c4f6d.mp3?filename=happy-ukulele-111858.mp3"></audio>
  <audio id="sfxCoin" src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_3a8c1f1dca.mp3?filename=bubble-pop-02-293341.mp3"></audio>
  <audio id="sfxHit" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_7b1a4c9a3b.mp3?filename=fail-144746.mp3"></audio>
  <div id="toastRoot"></div>
</div>

<script>
/* ------------------- STORAGE & DEFAULTS ------------------- */
const LS = {
  coins:'strike_coins', highest:'strike_highest', ownedSkins:'strike_ownedSkins', selectedSkin:'strike_selectedSkin', difficulty:'strike_difficulty', soundOn:'strike_soundOn', lives:'strike_lives', totalScore:'strike_totalScore', vipExpiry:'strike_vipExpiry', achievements:'strike_achievements', stats:'strike_stats', dailyChallenges:'strike_dailyChallenges'
};

const RANKS = [
  {name:'Recruit', threshold:0},
  {name:'Rookie', threshold:1000},
  {name:'Skirmisher', threshold:3000},
  {name:'Fighter', threshold:10000},
  {name:'Veteran', threshold:25000},
  {name:'Elite', threshold:50000},
  {name:'Champion', threshold:70000},
  {name:'Legend', threshold:100000},
  {name:'Mythic', threshold:250000},
  {name:'Ascendant', threshold:500000}
];

const defaultState = {
  coins: Number(localStorage.getItem(LS.coins) || 0),
  highest: Number(localStorage.getItem(LS.highest) || 0),
  ownedSkins: JSON.parse(localStorage.getItem(LS.ownedSkins) || '[]'),
  selectedSkin: localStorage.getItem(LS.selectedSkin) || 'red',
  difficulty: localStorage.getItem(LS.difficulty) || 'medium',
  soundOn: (localStorage.getItem(LS.soundOn)===null) ? true : JSON.parse(localStorage.getItem(LS.soundOn)),
  lives: Number(localStorage.getItem(LS.lives) || 1),
  totalScore: Number(localStorage.getItem(LS.totalScore) || 0),
  vipExpiry: Number(localStorage.getItem(LS.vipExpiry) || 0),
  achievements: JSON.parse(localStorage.getItem(LS.achievements) || '{}'),
  stats: JSON.parse(localStorage.getItem(LS.stats) || JSON.stringify({timePlayed:0, runs:0, enemies:0, powerups:0, coins:0})),
  dailyChallenges: JSON.parse(localStorage.getItem(LS.dailyChallenges) || '{}')
};
let state = {...defaultState};
if(!state.ownedSkins.includes('red')) state.ownedSkins.push('red');

function saveState(){
  localStorage.setItem(LS.coins, state.coins);
  localStorage.setItem(LS.highest, state.highest);
  localStorage.setItem(LS.ownedSkins, JSON.stringify(state.ownedSkins));
  localStorage.setItem(LS.selectedSkin, state.selectedSkin);
  localStorage.setItem(LS.difficulty, state.difficulty);
  localStorage.setItem(LS.soundOn, JSON.stringify(state.soundOn));
  localStorage.setItem(LS.lives, state.lives);
  localStorage.setItem(LS.totalScore, state.totalScore);
  localStorage.setItem(LS.vipExpiry, state.vipExpiry);
  localStorage.setItem(LS.achievements, JSON.stringify(state.achievements));
  localStorage.setItem(LS.stats, JSON.stringify(state.stats));
  localStorage.setItem(LS.dailyChallenges, JSON.stringify(state.dailyChallenges));
}

/* ------------------- ACHIEVEMENTS ------------------- */
/* extended achievements including rank-based awards */
const ACHS = [
  {id:'score_10k', title:'Score Novice', desc:'Συνολικό σκορ 10.000', check:()=> state.totalScore>=10000, reward:100},
  {id:'score_50k', title:'Score Pro', desc:'Συνολικό σκορ 50.000', check:()=> state.totalScore>=50000, reward:300},
  {id:'coins_500', title:'Coins Hoarder', desc:'Συνολικά 500 νομίσματα', check:()=> state.coins>=500, reward:150},
  {id:'skins_4', title:'Skin Collector', desc:'Έχεις 4 skins', check:()=> state.ownedSkins.length>=4, reward:200},
  {id:'vip_bought', title:'VIP Initiate', desc:'Αγόρασες VIP', check:()=> isVIP(), reward:50},
  // rank-based achievements (new)
  {id:'rank_rookie', title:'Rookie Achieved', desc:'Reached rank: Rookie', check:()=> getRankFromScore(state.highest).name === 'Rookie' || getRankFromScore(state.highest).index >= 1, reward:50},
  {id:'rank_fighter', title:'Fighter Achieved', desc:'Reached rank: Fighter', check:()=> getRankFromScore(state.highest).name === 'Fighter' || getRankFromScore(state.highest).index >= 3, reward:150},
  {id:'rank_champion', title:'Champion Achieved', desc:'Reached rank: Champion', check:()=> getRankFromScore(state.highest).name === 'Champion' || getRankFromScore(state.highest).index >= 6, reward:500},
];

function checkAchievements(){ let unlocked=[]; ACHS.forEach(a=>{ try{ if(a.check() && !state.achievements[a.id]){ state.achievements[a.id]=true; state.coins += a.reward; unlocked.push(a); showToast('Achievement unlocked: '+a.title); } }catch(e){ console.error('ach check error',e); } }); if(unlocked.length) { saveState(); renderAchievements(); updateDisplays(); } }

/* ------------------- VIP helpers ------------------- */
function isVIP(){ return Date.now() < (state.vipExpiry || 0); }
function daysLeftVIP(){ const ms = (state.vipExpiry||0) - Date.now(); return ms>0? Math.ceil(ms / (1000*60*60*24)) : 0; }

function grantDailyVIP(){ const key='strike_lastDaily'; const last = localStorage.getItem(key)||''; const today = new Date().toDateString(); if(isVIP() && last!==today){ localStorage.setItem(key,today); state.coins += 75; showToast('VIP daily bonus: +75 coins'); saveState(); updateDisplays(); } }

/* ------------------- DAILY CHALLENGES ------------------- */
/*
  The daily challenge is regenerated each day. Stored locally in state.dailyChallenges:
  { date: 'Tue Sep 09 2025', id:'monday_highest', title, desc, type, target, reward, completed:false, progress:0 }
*/
const WEEKLY_CHALLENGE_TEMPLATES = {
  1: {id:'monday_highest', title:'Monday — High Score Push', desc:'Get a highest score ≥ 10,000 today', type:'highest', target:10000, reward:100},
  2: {id:'tuesday_coins', title:'Tuesday — Coin Rush', desc:'Collect 200 coins in a single run', type:'collect', target:200, reward:75},
  3: {id:'wednesday_run', title:'Wednesday — Run & Win', desc:'Complete 1 run today', type:'runs', target:1, reward:25},
  4: {id:'thursday_enemies', title:'Thursday — Enemy Crusher', desc:'Defeat 50 enemies (total) today', type:'enemies', target:50, reward:80},
  5: {id:'friday_score', title:'Friday — Score Breaker', desc:'Score at least 50,000 in one run', type:'score_single', target:50000, reward:200},
  6: {id:'saturday_vip', title:'Saturday — VIP Trial', desc:'Buy VIP (simulated) today', type:'buy_vip', target:1, reward:300},
  0: {id:'sunday_time', title:'Sunday — Marathon', desc:'Play for 300 seconds today', type:'time', target:300, reward:100}
};

function ensureDailyChallenge(){
  const today = new Date().toDateString();
  if(!state.dailyChallenges || state.dailyChallenges.date !== today){
    const weekday = new Date().getDay(); // 0 Sun - 6 Sat
    const tpl = WEEKLY_CHALLENGE_TEMPLATES[weekday] || WEEKLY_CHALLENGE_TEMPLATES[1];
    state.dailyChallenges = {
      date: today,
      id: tpl.id,
      title: tpl.title,
      desc: tpl.desc,
      type: tpl.type,
      target: tpl.target,
      reward: tpl.reward,
      completed: false,
      progress: 0
    };
    // reset per-session counters for tracking
    sessionEarnedCoins = 0;
    saveState();
  }
}

function renderDaily(){
  ensureDailyChallenge();
  const d = state.dailyChallenges;
  const el = document.getElementById('dailyContent');
  const progressText = d.completed ? 'Completed' : `Progress: ${Math.floor(d.progress)}/${d.target}`;
  el.innerHTML = `<strong>${d.title}</strong><div class="small">${d.desc}</div><div style="height:8px"></div><div class="small">${progressText}</div><div style="height:6px"></div><div class="small">Reward: ${d.reward} coins</div>`;
  document.getElementById('claimDaily').disabled = !d.completed || d.claimed;
}

function checkDailyChallengeOnEvent(){
  // called whenever relevant events occur (coin collect, enemy defeat, gameOver, time tick)
  ensureDailyChallenge();
  const d = state.dailyChallenges;
  if(d.completed) return;
  switch(d.type){
    case 'highest':
      // highest today is the state.highest but also if current session score surpasses daily target
      if(state.highest >= d.target) d.completed = true;
      break;
    case 'collect':
      if(sessionEarnedCoins >= d.target) d.completed = true;
      d.progress = sessionEarnedCoins;
      break;
    case 'runs':
      // state.stats.runs tracks total runs — we need runs today; to keep it simple, allow any run increment to count for today
      // We'll track runsToday in dailyChallenges.progress
      d.progress = d.progress || 0;
      if(d.progress >= d.target) d.completed = true;
      break;
    case 'enemies':
      // accumulate in daily progress
      d.progress = d.progress || 0;
      if(d.progress >= d.target) d.completed = true;
      break;
    case 'score_single':
      if(latestRunMaxScore >= d.target) d.completed = true;
      d.progress = latestRunMaxScore;
      break;
    case 'buy_vip':
      if(d.progress >= 1) d.completed = true;
      break;
    case 'time':
      d.progress = d.progress || 0;
      if(d.progress >= d.target) d.completed = true;
      break;
  }
  if(d.completed){
    showToast('Daily challenge completed! Claim your reward.');
  }
  saveState();
}

document.getElementById('claimDaily').addEventListener('click', ()=>{
  ensureDailyChallenge();
  const d = state.dailyChallenges;
  if(d.completed && !d.claimed){
    state.coins += d.reward;
    d.claimed = true;
    saveState();
    updateDisplays();
    renderDaily();
    showToast('Daily reward claimed: +'+d.reward+' coins');
  } else showToast('Challenge not completed yet');
});
document.getElementById('backFromDaily').addEventListener('click', ()=>{ openMenu('menuMain'); });

/* ------------------- CANVAS + ENTITIES ------------------- */
const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
function fitCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', fitCanvas); fitCanvas();

const DIFF = { easy:{spawn:1100,speed:5.5,coinRate:0.12}, medium:{spawn:700,speed:8,coinRate:0.17}, hard:{spawn:420,speed:12,coinRate:0.22} };
let difficulty = state.difficulty;

function rnd(a,b){return Math.floor(Math.random()*(b-a))+a}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function shadeColor(color, percent){ const f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent; const R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; return '#'+(0x1000000 + (Math.round((t-R)*p/100)+R)*0x10000 + (Math.round((t-G)*p/100)+G)*0x100 + (Math.round((t-B)*p/100)+B)).toString(16).slice(1); }

const SKINS = { red:{color:'#ff4b4b',cost:0}, blue:{color:'#3aa0ff',cost:10}, green:{color:'#32d583',cost:50}, yellow:{color:'#ffd54a',cost:50}, purple:{color:'#a24cff',cost:500}, gold:{color:'#ffd700',cost:1000}, vip:{color:'#ff7aa2',cost:0,exclusive:true} };

// Entities
class Player{ constructor(){ this.x=120; this.y=canvas.height/2; this.r=18; this.skin=state.selectedSkin; this.revived=false; this.invincible=0; } render(){ ctx.save(); // shadow
 ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.ellipse(this.x+2,this.y+8,this.r+12,this.r+6,0,0,Math.PI*2); ctx.fill(); // body
 const col = SKINS[this.skin].color; const g = ctx.createLinearGradient(this.x-this.r,this.y-this.r,this.x+this.r,this.y+this.r); g.addColorStop(0,col); g.addColorStop(1,shadeColor(col,-25)); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.stroke(); if(isVIP()){ ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle='rgba(255,215,75,0.9)'; ctx.arc(this.x,this.y,this.r+8,0,Math.PI*2); ctx.stroke(); } if(this.invincible>0){ ctx.globalAlpha=0.8; ctx.beginPath(); ctx.lineWidth=3; ctx.strokeStyle='rgba(123,255,245,0.9)'; ctx.arc(this.x,this.y,this.r+14,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; } ctx.restore(); } }

class Obstacle{ constructor(type){ this.type=type||'normal'; this.w = this.type==='wide'? rnd(70,140) : rnd(36,90); this.h = rnd(20,56); this.x = canvas.width + this.w; this.y = rnd(40, canvas.height-40); this.speed = DIFF[difficulty].speed + Math.random()*1.5 + (this.type==='fast'?2:0); this.hp = this.type==='tank'?2:1; } update(dt){ this.x -= this.speed * dt; } render(){ ctx.save(); if(this.type==='bomb'){ ctx.fillStyle='rgba(30,30,30,0.95)'; ctx.fillRect(this.x-this.w/2,this.y-this.h/2,this.w,this.h); ctx.font='20px monospace'; ctx.fillStyle='white'; ctx.textAlign='center'; ctx.fillText('💣', this.x, this.y+6); } else { const grad = ctx.createLinearGradient(this.x-this.w/2,this.y-this.h/2,this.x+this.w/2,this.y+this.h/2); grad.addColorStop(0,'#3bd6b8'); grad.addColorStop(1,'#1f9bd1'); ctx.fillStyle=grad; ctx.fillRect(this.x-this.w/2,this.y-this.h/2,this.w,this.h); ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.strokeRect(this.x-this.w/2,this.y-this.h/2,this.w,this.h); } ctx.restore(); } }

class Coin{ constructor(){ this.x = canvas.width + 20; this.y = rnd(60,canvas.height-60); this.r = 10; this.speed = DIFF[difficulty].speed + 1; } update(dt){ this.x -= this.speed * dt; } render(){ ctx.save(); ctx.beginPath(); ctx.fillStyle='gold'; ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke(); ctx.restore(); } }

class Powerup{ constructor(kind){ this.kind=kind||'double'; this.x=canvas.width+40; this.y=rnd(80,canvas.height-80); this.r=14; this.speed=DIFF[difficulty].speed+0.8; } update(dt){ this.x -= this.speed*dt; } render(){ ctx.save(); ctx.beginPath(); ctx.fillStyle = this.kind==='shield'?'#7afcff':'#ffd54a'; ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(this.x-12,this.y-2,24,4); ctx.restore(); } }

/* Game state */
let player = new Player(); let obstacles=[]; let coinsArr=[]; let powerups=[]; let particles=[]; let running=false; let lastSpawn=0; let lastCoinSpawn=0; let lastPowSpawn=0; let score=0; let level=1; let lastTime = performance.now();

/* session trackers used for daily challenges */
let sessionEarnedCoins = 0; // coins earned in current run/session (for daily collect)
let latestRunMaxScore = 0; // track highest score in latest run (for daily)
let sessionTimeAccum = 0; // accumulate play time per day (seconds)

/* Input */
let targetY = player.y; window.addEventListener('keydown', e=>{ if(e.key==='ArrowUp') targetY -= 60; if(e.key==='ArrowDown') targetY += 60; });
let touching=false; window.addEventListener('pointerdown', e=>{ touching=true; targetY=e.clientY; }); window.addEventListener('pointermove', e=>{ if(touching) targetY=e.clientY; }); window.addEventListener('pointerup', e=>{ touching=false; });

/* particles */
function makeParticles(x,y,col,count){ for(let i=0;i<count;i++) particles.push({x,y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,life:60+Math.random()*30,col}); }

/* loop */
function loop(now){ const dt = Math.min((now-lastTime)/16.67,4); lastTime = now; // update stats time
 const secondsElapsed = (dt * 16.67) / 1000;
 state.stats.timePlayed += secondsElapsed; // seconds
 sessionTimeAccum += secondsElapsed;
 // daily time accumulation
 if(state.dailyChallenges && state.dailyChallenges.type === 'time'){ state.dailyChallenges.progress = (state.dailyChallenges.progress||0) + secondsElapsed; }
 ctx.clearRect(0,0,canvas.width,canvas.height); drawBackground(); player.y += (targetY - player.y) * 0.18 * Math.min(dt,2); player.y = clamp(player.y,20,canvas.height-20); player.render(); if(running){ lastSpawn += 16.67*dt; if(lastSpawn > DIFF[difficulty].spawn){ lastSpawn=0; // spawn enemy type randomly
   const r = Math.random(); if(r<0.12) obstacles.push(new Obstacle('fast')); else if(r<0.22) obstacles.push(new Obstacle('tank')); else obstacles.push(new Obstacle('normal')); }
  lastCoinSpawn += 16.67*dt; if(lastCoinSpawn > 900){ lastCoinSpawn=0; if(Math.random() < DIFF[difficulty].coinRate) coinsArr.push(new Coin()); }
  lastPowSpawn += 16.67*dt; if(lastPowSpawn > 6000){ lastPowSpawn=0; if(Math.random()<0.25) powerups.push(new Powerup(Math.random()<0.5?'shield':'double')); }
 }
 // coins
 for(let i=coinsArr.length-1;i>=0;i--){ const c=coinsArr[i]; c.update(dt); c.render(); if(c.x < -30) coinsArr.splice(i,1); if(collideCircleRect(player.x,player.y,player.r, c.x-c.r, c.y-c.r, c.r*2, c.r*2)){ coinsArr.splice(i,1); score += 10; const coinGain = isVIP()?2:1; state.coins += coinGain; state.totalScore += 10; state.stats.coins = (state.stats.coins||0)+coinGain; sessionEarnedCoins += coinGain; saveState(); if(state.soundOn) document.getElementById('sfxCoin').play(); makeParticles(c.x,c.y,'#ffd54a',10); updateDisplays(); checkAchievements(); checkDailyChallengeOnEvent(); } }
 // powerups
 for(let i=powerups.length-1;i>=0;i--){ const p=powerups[i]; p.update(dt); p.render(); if(p.x < -30) powerups.splice(i,1); if(collideCircleRect(player.x,player.y,player.r, p.x-p.r, p.y-p.r, p.r*2, p.r*2)){ powerups.splice(i,1); applyPowerup(p.kind); state.stats.powerups++; saveState(); showToast('Power-up: '+p.kind); } }
 // obstacles
 for(let i=obstacles.length-1;i>=0;i--){ const o=obstacles[i]; o.update(dt); o.render(); if(o.x + o.w < -50){ obstacles.splice(i,1); score += 20; state.totalScore += 20; state.stats.enemies = (state.stats.enemies||0)+1; updateLevelByScore(); updateDisplays(); saveState(); // update daily enemy progress
   if(state.dailyChallenges && state.dailyChallenges.type === 'enemies'){ state.dailyChallenges.progress = (state.dailyChallenges.progress||0) + 1; checkDailyChallengeOnEvent(); }
 } else if(collideCircleRect(player.x,player.y,player.r, o.x-o.w/2, o.y-o.h/2, o.w, o.h)){
   // collision
   obstacles.splice(i,1);
   if(isVIP() && !player.revived){ player.revived = true; showToast('VIP Revive used!'); makeParticles(player.x,player.y,'#ffd54a',30); // don't reduce lives
   } else if(player.invincible>0){ showToast('Invincible! No damage'); } else { state.lives -= 1; saveState(); makeParticles(player.x,player.y,'#ff6b6b',20); if(state.soundOn) document.getElementById('sfxHit').play(); updateDisplays(); if(state.lives <= 0){ gameOver(); } }
 }
 }
 // particles
 for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life--; if(p.life<=0) particles.splice(i,1); else{ ctx.globalAlpha = Math.max(p.life/100,0); ctx.fillStyle=p.col; ctx.fillRect(p.x,p.y,3,3); ctx.globalAlpha=1; } }
 // update invincible timer
 if(player.invincible>0) player.invincible -= (dt*16.67);
 if(running) requestAnimationFrame(loop);
}

function drawBackground(){ const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height); g.addColorStop(0,'rgba(0,0,0,0.06)'); g.addColorStop(1,'rgba(255,255,255,0.02)'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height); }

function collideCircleRect(cx,cy,cr, rx,ry,rw,rh){ const closestX = clamp(cx, rx, rx+rw); const closestY = clamp(cy, ry, ry+rh); const dx = cx - closestX; const dy = cy - closestY; return (dx*dx + dy*dy) < (cr*cr); }

/* ------------------- Powerups & helpers ------------------- */
let activePower = {double:false,shield:false};
function applyPowerup(kind){ if(kind==='double'){ activePower.double = true; setTimeout(()=>{ activePower.double=false; showToast('Double ended'); },8000); showToast('Double points for 8s'); }
 if(kind==='shield'){ player.invincible = 6000; showToast('Shield active 6s'); }
}

/* ------------------- Game control helpers ------------------- */
function startGame(){ 
  player = new Player(); player.skin = state.selectedSkin; player.revived=false; player.invincible=0; targetY=player.y; obstacles=[]; coinsArr=[]; powerups=[]; particles=[]; score=0; level=1; state.lives = state.lives || 1; state.stats.runs = (state.stats.runs||0)+1; saveState(); updateDisplays(); grantDailyVIP(); 
  // reset session trackers
  sessionEarnedCoins = 0;
  latestRunMaxScore = 0;
  sessionTimeAccum = 0;
  // add playing class to shrink UI and hide controls
  document.body.classList.add('playing');
  if(!running){ running=true; lastTime = performance.now(); requestAnimationFrame(loop); } 
  closeAllMenus(false); 
}
function pauseGame(){ running=false; document.body.classList.remove('playing'); }
function resumeGame(){ if(!running){ running=true; document.body.classList.add('playing'); lastTime = performance.now(); requestAnimationFrame(loop); } }

function gameOver(){ running=false; document.body.classList.remove('playing'); // track latest run max score
 latestRunMaxScore = Math.max(latestRunMaxScore, score);
 // update highest and detect rank-up reward
 const prevHighest = state.highest;
 const prevRank = getRankFromScore(prevHighest).index;
 if(score > state.highest){
   state.highest = score;
   // compute new rank and reward accordingly
   const newRank = getRankFromScore(state.highest);
   const newRankIndex = newRank.index;
   if(newRankIndex > prevRank){
     // reward coins for rank up
     const rankUpCoins = (newRankIndex - prevRank) * 200;
     state.coins += rankUpCoins;
     showToast('Rank up! '+newRank.name+' (+'+rankUpCoins+' coins)', 3000);
   }
   showRankUpAnimation(prevRank);
 }
 state.totalScore += score;
 saveState();
 updateDisplays();
 checkAchievements();
 // update daily challenge run progress
 if(state.dailyChallenges && state.dailyChallenges.type === 'runs'){
   state.dailyChallenges.progress = (state.dailyChallenges.progress||0) + 1;
 }
 checkDailyChallengeOnEvent();
 setTimeout(()=>{ alert('Game Over — Score: '+score); openMenu('menuMain'); },50); 
}

function updateLevelByScore(){ const newLevel = Math.floor(score/500)+1; if(newLevel !== level){ level = newLevel; document.getElementById('levelDisplay').innerText = 'Level: '+level; } }

/* ------------------- UI & Menus ------------------- */
const skinsList = document.getElementById('skinsList');
const shopRange = document.getElementById('shopRange');
const shopLeft = document.getElementById('shopLeft');
const shopRight = document.getElementById('shopRight');

function renderSkins(){ skinsList.innerHTML=''; for(const key in SKINS){ const s=SKINS[key]; const card=document.createElement('div'); card.className='skinCard'; const preview=document.createElement('div'); preview.className='skinPreview'; preview.style.background=s.color; const label=document.createElement('div'); label.innerText=key.charAt(0).toUpperCase()+key.slice(1); const price=Math.ceil((s.cost||0)*(isVIP()?0.5:1)); const cost=document.createElement('div'); cost.className='small'; cost.innerText = (s.cost>0? price+' coins' : (s.exclusive? 'VIP only' : 'free')); const btn=document.createElement('button'); btn.className='btn'; btn.innerText = (state.ownedSkins.includes(key)? (state.selectedSkin===key? 'Selected':'Select') : 'Buy'); btn.onclick = ()=>{ if(s.exclusive && !isVIP()){ showToast('Exclusive: VIP only'); return; } if(state.ownedSkins.includes(key)){ state.selectedSkin = key; saveState(); player.skin = key; updateDisplays(); renderSkins(); showToast('Skin selected'); } else { if(state.coins >= price){ state.coins -= price; state.ownedSkins.push(key); state.selectedSkin = key; saveState(); player.skin = key; updateDisplays(); renderSkins(); showToast('Skin bought!'); checkAchievements(); } else showToast('Not enough coins'); } }; card.appendChild(preview); card.appendChild(label); card.appendChild(cost); card.appendChild(btn); skinsList.appendChild(card); } 
  // after rendering update slider range
  setTimeout(updateShopRange, 60);
}
renderSkins();

function updateShopRange(){
  const maxScroll = Math.max(0, skinsList.scrollWidth - skinsList.clientWidth);
  shopRange.max = maxScroll;
  // keep current scroll position in range
  shopRange.value = Math.round(skinsList.scrollLeft || 0);
}

/* shop controls: slider & arrows & drag */
shopRange.addEventListener('input', (e)=>{ skinsList.scrollLeft = Number(e.target.value); });
skinsList.addEventListener('scroll', ()=>{ shopRange.value = Math.round(skinsList.scrollLeft); });

shopLeft.addEventListener('click', ()=>{ const step = Math.floor(skinsList.clientWidth * 0.6); skinsList.scrollBy({left: -step, behavior:'smooth'}); });
shopRight.addEventListener('click', ()=>{ const step = Math.floor(skinsList.clientWidth * 0.6); skinsList.scrollBy({left: step, behavior:'smooth'}); });

// add drag-to-scroll for skinsList
let isDown = false, startX, scrollLeftStart;
skinsList.addEventListener('pointerdown', (e)=>{ isDown = true; skinsList.setPointerCapture(e.pointerId); startX = e.clientX; scrollLeftStart = skinsList.scrollLeft; skinsList.style.cursor = 'grabbing'; });
skinsList.addEventListener('pointermove', (e)=>{ if(!isDown) return; const dx = e.clientX - startX; skinsList.scrollLeft = scrollLeftStart - dx; });
skinsList.addEventListener('pointerup', (e)=>{ isDown = false; try{ skinsList.releasePointerCapture(e.pointerId); }catch(e){} skinsList.style.cursor = ''; });
skinsList.addEventListener('pointerleave', ()=>{ isDown = false; skinsList.style.cursor = ''; });

/*
  openMenu/closeAllMenus adjustments:
  - When a menu opens, ensure body.playing is removed so full-sized UI and controls show.
  - When menus close, if the game is running we re-enable .playing (so collapsed UI & hidden buttons).
*/
function closeAllMenus(shouldResume = true){
  document.getElementById('overlay').style.display='none';
  document.querySelectorAll('.menu').forEach(m=>m.style.display='none');
  document.body.classList.remove('modal-open');
  if(shouldResume){
    // resume the game and set playing mode if running
    if(running) resumeGame(); else document.body.classList.remove('playing');
  } else {
    // do not resume (used when starting a new game that already set playing)
    if(running) document.body.classList.add('playing');
  }
}
function openMenu(id){
  document.getElementById('overlay').style.display='flex';
  document.querySelectorAll('.menu').forEach(m=>m.style.display='none');
  document.getElementById(id).style.display='block';
  document.body.classList.add('modal-open');
  // show normal-sized UI and show controls while in menu
  document.body.classList.remove('playing');
  pauseGame();
  // update shop slider when shop opens
  if(id === 'menuShop') setTimeout(updateShopRange,80);
  if(id === 'menuDaily') setTimeout(renderDaily,40);
  if(id === 'menuBuy') setTimeout(()=>{/* noop */},40);
}

/* initial: intro */
const bgMusic = document.getElementById('bgMusic'); 
document.getElementById('introStart').addEventListener('click', ()=>{ bgMusic.play().catch(()=>{}); document.getElementById('intro').style.display='none'; openMenu('menuMain'); grantDailyVIP(); });
document.getElementById('introSkip').addEventListener('click', ()=>{ document.getElementById('intro').style.display='none'; openMenu('menuMain'); });
document.getElementById('introPlay').addEventListener('click', ()=>{ document.getElementById('intro').style.display='none'; startGame(); });
document.getElementById('introShop').addEventListener('click', ()=>{ document.getElementById('intro').style.display='none'; openMenu('menuShop'); renderSkins(); });
document.getElementById('introAch').addEventListener('click', ()=>{ document.getElementById('intro').style.display='none'; openMenu('menuAch'); renderAchievements(); });
document.getElementById('introSettings').addEventListener('click', ()=>{ document.getElementById('intro').style.display='none'; openMenu('menuSettings'); });
document.getElementById('introReset').addEventListener('click', ()=>{ if(confirm('Reset all progress?')){ localStorage.clear(); location.reload(); } });

document.getElementById('startFromMenu').addEventListener('click', startGame);
document.getElementById('playBtn').addEventListener('click', startGame);

document.getElementById('shopBtn').addEventListener('click', ()=>{ openMenu('menuShop'); renderSkins(); });
document.getElementById('openShopFromMenu').addEventListener('click', ()=>{ openMenu('menuShop'); renderSkins(); });
document.getElementById('backFromShop').addEventListener('click', ()=>{ openMenu('menuMain'); });

document.getElementById('openBuyMenu').addEventListener('click', ()=>{ openMenu('menuBuy'); });

document.getElementById('buyLife').addEventListener('click', ()=>{ const price = Math.ceil(100*(isVIP()?0.5:1)); if(state.coins>=price && state.lives < 5){ state.coins -= price; state.lives += 1; saveState(); updateDisplays(); showToast('Extra life purchased!'); } else if(state.lives>=5) showToast('Max lives reached'); else showToast('Not enough coins'); });

// VIP purchase with coins (original simple method)
document.getElementById('buyVipCoins').addEventListener('click', ()=>{ const cost=3000; if(state.coins >= cost){ state.coins -= cost; state.vipExpiry = Date.now() + 30*24*60*60*1000; if(!state.ownedSkins.includes('vip')) state.ownedSkins.push('vip'); state.lives = Math.max(state.lives,3); saveState(); updateDisplays(); renderSkins(); showToast('VIP ενεργοποιήθηκε για 1 μήνα!'); checkAchievements(); // daily challenge progress for buy_vip
  if(state.dailyChallenges && state.dailyChallenges.type === 'buy_vip'){ state.dailyChallenges.progress = (state.dailyChallenges.progress||0) + 1; checkDailyChallengeOnEvent(); }
 } else showToast('Δεν έχεις αρκετά νομίσματα'); });

document.getElementById('settingsBtn').addEventListener('click', ()=>{ openMenu('menuSettings'); });
document.getElementById('backFromSettings').addEventListener('click', ()=>{ openMenu('menuMain'); });

document.getElementById('toggleSound').addEventListener('click', ()=>{ state.soundOn = !state.soundOn; saveState(); document.getElementById('toggleSound').innerText = state.soundOn? 'Sound: On':'Sound: Off'; showToast('Sound: '+(state.soundOn? 'On':'Off')); });
document.getElementById('toggleSound').innerText = state.soundOn? 'Sound: On':'Sound: Off';

document.getElementById('resetBtn').addEventListener('click', ()=>{ if(confirm('Reset all progress?')){ localStorage.clear(); location.reload(); } });

document.getElementById('clearSaves').addEventListener('click', ()=>{ if(confirm('Clear saved coins, skins and settings?')){ localStorage.removeItem(LS.coins); localStorage.removeItem(LS.ownedSkins); localStorage.removeItem(LS.selectedSkin); localStorage.removeItem(LS.highest); localStorage.removeItem(LS.lives); localStorage.removeItem(LS.totalScore); localStorage.removeItem(LS.vipExpiry); localStorage.removeItem(LS.achievements); localStorage.removeItem(LS.stats); localStorage.removeItem(LS.dailyChallenges); location.reload(); } });

document.getElementById('achBtn').addEventListener('click', ()=>{ openMenu('menuAch'); renderAchievements(); });
document.getElementById('backFromAch').addEventListener('click', ()=>{ openMenu('menuMain'); });

document.getElementById('claimAll').addEventListener('click', ()=>{ showToast('Τα rewards δίνονται αυτόματα κατά το ξεκλείδωμα.'); });

document.getElementById('statsBtn').addEventListener('click', ()=>{ openMenu('menuStats'); renderStats(); });
document.getElementById('backFromStats').addEventListener('click', ()=>{ openMenu('menuMain'); });

/* Difficulty */
function setDifficulty(d){ if(d==='hard' && !isVIP()){ showToast('Hard είναι διαθέσιμο μόνο για VIP'); return; } difficulty=d; state.difficulty=d; saveState(); document.getElementById('difEasy').classList.toggle('active', d==='easy'); document.getElementById('difMed').classList.toggle('active', d==='medium'); document.getElementById('difHard').classList.toggle('active', d==='hard'); }
document.getElementById('difEasy').addEventListener('click', ()=>setDifficulty('easy'));
document.getElementById('difMed').addEventListener('click', ()=>setDifficulty('medium'));
document.getElementById('difHard').addEventListener('click', ()=>setDifficulty('hard'));
setDifficulty(state.difficulty);

/* ------------------- Ranks & UI updates ------------------- */
function getRankFromScore(hs){ for(let i=RANKS.length-1;i>=0;i--){ if(hs >= RANKS[i].threshold) return {index:i, ...RANKS[i]}; } return {index:0, ...RANKS[0]}; }

function updateDisplays(){ document.getElementById('coinsDisplay').innerText = 'Coins: '+state.coins; document.getElementById('scoreDisplay').innerText = 'Score: '+score; document.getElementById('highDisplay').innerText = 'Highest: '+state.highest; document.getElementById('lives').innerText = '❤ x'+(state.lives||0); document.getElementById('totalScoreDisplay').innerText = 'Total: '+state.totalScore; const vipEl = document.getElementById('vipPanel'); if(isVIP()){ vipEl.innerHTML = '<span class="vipBadge">VIP • '+daysLeftVIP()+'d</span>'; } else vipEl.innerHTML = 'VIP: —'; const rank = getRankFromScore(state.highest); document.getElementById('rankPanel').innerHTML = 'Rank: <span class="rankBadge">'+rank.name+'</span>'; }

function renderAchievements(){ const list = document.getElementById('achList'); list.innerHTML=''; ACHS.forEach(a=>{ const el = document.createElement('div'); el.className='achItem '+(state.achievements[a.id]?'achUnlocked':''); el.innerHTML = '<div><strong>'+a.title+'</strong><div class="small">'+a.desc+'</div></div><div>'+(state.achievements[a.id]? 'Unlocked':'Locked')+'</div>'; list.appendChild(el); }); }

function renderStats(){ const c = document.getElementById('statsContent'); const s = state.stats; const lines = [
  'Total time played: '+Math.floor(s.timePlayed)+'s',
  'Runs played: '+(s.runs||0),
  'Enemies defeated: '+(s.enemies||0),
  'Powerups used: '+(s.powerups||0),
  'Coins earned (total): '+(state.totalScore||0)
]; c.innerHTML = lines.join('<br>'); }

/* Rank up animation (now accepts prevRankIndex optionally) */
function showRankUpAnimation(prevRankIndex = 0){ const rank = getRankFromScore(state.highest); showToast('Νέος βαθμός: '+rank.name,2000); // small sparkles
 for(let i=0;i<12;i++){ const sp = document.createElement('div'); sp.className='sparkle'; sp.style.left = (50 + Math.random()*40-20)+'%'; sp.style.top = (50 + Math.random()*40-20)+'%'; document.body.appendChild(sp); setTimeout(()=>sp.remove(),1600); } }

/* ------------------- Utilities */
function showToast(txt,timeout=2200){ const t=document.createElement('div'); t.className='toast'; t.innerText=txt; document.body.appendChild(t); setTimeout(()=>{ t.style.opacity=0; setTimeout(()=>t.remove(),400); },timeout); }

/* safe audio play to avoid exceptions (bg music starts only on user gesture) */
function safePlaySound(id, loop=false){
  try{
    const el = (id==='bgMusic') ? bgMusic : document.getElementById(id);
    if(!el) return;
    if(loop) el.loop = true;
    if(state.soundOn){
      el.currentTime = 0;
      el.play().catch(()=>{ /* ignore */ });
    }
  }catch(e){}
}

/* ------------------- Hide/Show stats toggle ------------------- */
const toggleStatsBtn = document.getElementById('toggleStatsView');
const hudRight = document.getElementById('hudRight');
let statsHidden = false;
toggleStatsBtn.addEventListener('click', ()=>{
  statsHidden = !statsHidden;
  if(statsHidden){
    hudRight.classList.add('hidden');
    toggleStatsBtn.innerText = 'Show Stats';
  } else {
    hudRight.classList.remove('hidden');
    toggleStatsBtn.innerText = 'Hide Stats';
  }
});

/* ------------------- Payment (Simulated) ------------------- */
/* This is a local simulated payment flow: DO NOT send sensitive data anywhere.
   It validates simple formats and credits coins only locally. */
document.getElementById('submitPayment').addEventListener('click', ()=>{
  const name = document.getElementById('cardName').value.trim();
  const num = (document.getElementById('cardNumber').value || '').replace(/\s+/g,'');
  const exp = (document.getElementById('cardExpiry').value || '').trim();
  const cvc = (document.getElementById('cardCVC').value || '').trim();
  const amt = Number(document.getElementById('cardAmount').value || 1);

  // basic validation (format only)
  if(!name || !/^\d{13,19}$/.test(num) || !/^\d{2}\/\d{2}$/.test(exp) || !/^\d{3,4}$/.test(cvc)){
    showToast('Payment info invalid — please use test data (simulated).');
    return;
  }
  // Simulate processing
  showToast('Processing payment...', 1800);
  setTimeout(()=>{
    // credit coins mapping
    const creditMap = {1:100,5:600,10:1300,20:3000};
    const coins = creditMap[amt] || Math.round(amt * 100);
    state.coins += coins;
    saveState();
    updateDisplays();
    showToast('Payment successful : +'+coins+' coins');
    // For daily challenge that requires buy_vip/any buy, we could update progress.
    closeAllMenus();
  }, 1600);
});
document.getElementById('backFromBuy').addEventListener('click', ()=>{ openMenu('menuShop'); });

/* ------------------- Initial states & loop setup ------------------- */
(function init(){ if(state.ownedSkins.includes('vip') || state.highest > 2000) document.querySelector('.legend').style.display='block'; else document.querySelector('.legend').style.display='none'; if(!targetY) targetY = canvas.height/2; updateDisplays(); renderSkins(); renderAchievements(); renderStats(); // auto-check achievements
 checkAchievements(); // ensure daily challenge exists for today
 ensureDailyChallenge();
 setInterval(()=>{ if(document.visibilityState==='visible'){ updateDisplays(); renderSkins(); checkAchievements(); checkDailyChallengeOnEvent(); } },5000);
 // ensure intro controls reflect main controls' state (sound label etc)
 document.getElementById('toggleSound').innerText = state.soundOn? 'Sound: On':'Sound: Off';
 // hook daily button
 document.getElementById('dailyBtn').addEventListener('click', ()=>{ openMenu('menuDaily'); renderDaily(); });
})();

/* overlay outside click close */
document.getElementById('overlay').addEventListener('click',(e)=>{ if(e.target.id==='overlay') closeAllMenus(); });

</script>
</body>
</html>

